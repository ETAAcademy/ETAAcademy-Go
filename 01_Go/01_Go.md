# ETAAcademy-Go: 01. Non-OOP, Interface, Pointer and Goroutine

<table>
  <tr>
    <th>title</th>
    <th>tags</th>
  </tr>
  <tr>
    <td>01. TCP</td>
    <td>
      <table>
        <tr>
          <th>go</th>
          <th>basic</th>
          <td>TCP</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

[Github](https:github.com/ETAAcademy)｜[Twitter](https:twitter.com/ETAAcademy)｜[ETA-Go](https://github.com/ETAAcademy/ETAAcademy-Go)

Authors: [Eta](https:twitter.com/pwhattie), looking forward to your joining

# Four Divine Beasts of Go Programming

In this article, we will explore the four legendary beasts of the Go programming language: Non-OOP, Interface, Pointer, and Goroutine. Each of these concepts plays a crucial role in defining Go's unique approach to programming, providing developers with powerful tools to write efficient and flexible code.

## 1. Non-OOP

Go takes a unique approach to object-oriented programming by using structs and composition rather than traditional classes and inheritance. Methods can be associated with structs to encapsulate behavior, and constructors are implemented as regular functions, often prefixed with "New" for clarity. Through these principles, Go achieves flexibility, readability, and reusability in an efficient, lightweight way.

### 1.1 Structs in Go

In Go, `struct`s are similar to those in C but without the concept of classes or inheritance; instead, Go uses composition. Structs in Go are defined with `type <Name> struct{}` syntax and follow visibility rules based on name capitalization. They can contain pointers to themselves, support anonymous fields, and can be used in maps as values. Structs can be initialized with literals, support direct copying between instances of the same type, and allow for `==` and `!=` comparisons but not `>` or `<`. Additionally, comparison is only possible between structs of the same type and name.

#### Declaring a Struct

In Go, struct declarations are somewhat similar to anonymous classes in C#, though Go has no classes. Fields are accessed with dot notation, as in the example below:

<details><summary><b> Code</b></summary>

```go
var curiosity struct {
    lat  float64
    long float64
}

curiosity.lat = -4.9773
curiosity.long = 137.4283

fmt.Println(curiosity.lat, curiosity.long) // Output: -4.9773 137.4283
fmt.Println(curiosity) // Output: {-4.9773 137.4283}

```

</details>

Assigning a struct to a new variable creates a **copy of the values**:

<details><summary><b> Code</b></summary>

```go
curiosityMarkII := curiosity // Copy the struct
curiosity.lat = 0
fmt.Println(curiosity)       // Output: {0 137.4283}
fmt.Println(curiosityMarkII) // Output: {-4.9773 137.4283}; Original remains unchanged
```

</details>

#### Declaring a Reusable Struct with `type`

While anonymous struct types can be useful, it’s often more practical to define a named struct that can be reused. Use `type`, followed by the struct name, and then `struct` to declare it.

<details><summary><b> Code</b></summary>

```go
type location struct {
    lat  float64
    long float64
}

func main() {
    var spirit location
    spirit.lat = -14.5637
    spirit.long = 175.3774

    var opportunity location
    opportunity.lat = -1.9473
    opportunity.long = 352.8434

    fmt.Println(spirit)       // Output: {-14.5637 175.3774}
    fmt.Println(opportunity)  // Output: {-1.9473 352.8434}
}
```

</details>

Structs can also be initialized using literals, either by specifying fields explicitly or by following the field order.

<details><summary><b> Code</b></summary>

```go
spirit1 := location{lat: -14.5637, long: 175.3774}
spirit2 := location{-14.5684, 175.472636}
fmt.Println(spirit1)
```

</details>

To print struct data, `fmt.Printf` with `%+v` includes field names, while `%v` omits them.

<details><summary><b> Code</b></summary>

```go
fmt.Printf("%v\n", curiosity)  // Output: {0 137.4283}
fmt.Printf("%+v\n", curiosity) // Output: {lat:0 long:137.4283}
```

</details>

#### Slices as Structs

As seen previously, slices in Go have properties like `append`, length, and capacity. Under the hood, slices are also structs. Here’s an example of defining a slice of structs:

<details><summary><b> Code</b></summary>

```go
type location struct {
    name string
    lat  float64
    long float64
}

locations := []location{
    {name: "Bradbury Landing", lat: -4.5895, long: 137.4417},
    {name: "Columbia Memorial Station", lat: -14.5684, long: 175.472636},
    {name: "Challenger Memorial Station", lat: -1.9462, long: 354.4734},
}
```

</details>

#### JSON Serialization (Encoding a Struct as JSON)

In many applications, struct data needs to be transmitted over a network in JSON format. In Go, the `Marshal` function in the `json` package encodes data as JSON, returning the result as bytes, which can then be converted to a string for readability.

<details><summary><b> Code</b></summary>

```go
import (
    "encoding/json"
    "fmt"
    "os"
)

type location struct {
    lat  float64
    long float64
}

func main() {
    spirit := location{lat: -14.5637, long: 175.3774}
    bytes, err := json.Marshal(spirit)
    exitOnError(err)
    fmt.Println(string(bytes)) // Output as a string
}

func exitOnError(err error) {
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}
```

</details>

Here, you may notice the output is `{}`. This is because JSON serialization in Go only includes fields that start with a capital letter. In Go, fields that start with uppercase letters are public, similar to public attributes in C#.

<details><summary><b> Code</b></summary>

```go
type locationV2 struct {
    Lat  float64
    Long float64
}

spiritV2 := locationV2{Lat: 12.433, Long: 144.843}
bytes, err := json.Marshal(spiritV2)
exitOnError(err)
fmt.Println(string(bytes)) // Output: {"Lat":12.433,"Long":144.843}
```

</details>

To control JSON field names, Go allows the use of struct tags, similar to attributes in C#:

<details><summary><b> Code</b></summary>

```go
type locationV3 struct {
    Lat  float64 `json:"latitude"`
    Long float64 `json:"longitude"`
}

spiritV3 := locationV3{Lat: 12.433, Long: 144.843}
bytesV3, errV3 := json.Marshal(spiritV3)
exitOnError(errV3)
fmt.Println(string(bytesV3)) // Output: {"latitude":12.433,"longitude":144.843}
```

</details>

In this example, the field names in the JSON output are customized using struct tags for clarity.

Go’s struct functionality, alongside features like composition instead of inheritance and control over JSON serialization, makes it both a flexible and efficient option for structuring data within Go applications.

### 1.2 Go: A Language Without Classes

Go is unique among many languages in that it has no concept of classes, objects, or inheritance. Instead, Go provides structs and methods, which can be combined to achieve much of the functionality traditionally associated with classes.

#### Attaching Methods to Structs

In Go, methods can be attached to structs in the same way as with basic types. This allows you to define behavior directly on the struct type. Here’s an example:

<details><summary><b> Code</b></summary>

```go
package main

import (
    "fmt"
    "math"
)

// Coordinate in degrees, minutes, seconds in a N/S/E/W hemisphere.
type coordinate struct {
    d, m, s float64
    h rune
}

// decimal converts a d/m/s coordinate to decimal degrees.
func (c coordinate) decimal() float64 {
    sign := 1.0
    switch c.h {
    case 'S', 'W', 's', 'w':
        sign = -1
    }
    return sign * (c.d + c.m/60 + c.s/3600)
}

type location struct {
    lat, long float64
}

func main() {
    // Bradbury Landing: 4º35'22.2" S, 137º26'30.1" E
    lat := coordinate{4, 35, 22.2, 'S'}
    long := coordinate{137, 26, 30.12, 'E'}

    fmt.Println(lat.decimal(), long.decimal())

    curiosity := location{lat.decimal(), long.decimal()}

    fmt.Println(curiosity)
}
```

</details>

In this example, we create a `coordinate` struct and a method `decimal()` that converts the coordinate from degrees, minutes, and seconds to decimal degrees. By calling `decimal()` on instances of `coordinate`, we can convert values as needed, achieving functionality similar to methods in a traditional class.

#### Constructors

Go does not have constructors in the traditional sense. Instead, you define functions that return instances of structs. For readability, these functions are typically prefixed with `New` or `new` (the lowercase variant is often used for unexported functions):

<details><summary><b> Code</b></summary>

```go
type location struct {
 lat, long float64
}
curiosity := location{lat.decimal(), long.decimal()}

// newLocation from latitude, longitude d/m/s coordinates.
func newLocation(lat, long coordinate) location {
 return location{lat.decimal(), long.decimal()}
}

func main() {
	// Bradbury Landing: 4º35'22.2" S, 137º26'30.1" E
	lat := coordinate{4, 35, 22.2, 'S'}
	long := coordinate{137, 26, 30.12, 'E'}

	fmt.Println(lat.decimal(), long.decimal())

	curiosity := newLocation(coordinate{4, 35, 22.2, 'S'}, coordinate{137, 26, 30.12, 'E'})
	fmt.Println(curiosity)
}

```

</details>

In this example, `newLocation` acts as a factory function that takes `coordinate` instances as input, converts them to decimal degrees, and initializes a new `location`. Naming conventions such as `NewLocation` make the code intuitive, as it clearly conveys the function's purpose.

Go’s `error` package also uses this convention, with functions named `New` that generate new error messages. The use of `error.New()` indicates that this is part of the `error` package, making the code both meaningful and concise.

#### Structs as a Substitute for Classes

Go achieves much of the functionality associated with classes by using structs and attached methods. Though Go lacks inheritance, it supports composition and delegation to achieve similar outcomes. For example, rather than inheriting properties and behavior, structs can include other structs as fields, leveraging the embedded fields' properties and methods.

<details><summary><b> Code</b></summary>

```go
type world struct {
 radius float64
}

// distance calculation using the Spherical Law of Cosines.
func (w world) distance(p1, p2 location) float64 {
 s1, c1 := math.Sincos(rad(p1.lat))
 s2, c2 := math.Sincos(rad(p2.lat))
 clong := math.Cos(rad(p1.long - p2.long))
 return w.radius * math.Acos(s1*s2+c1*c2*clong)
}

// rad converts degrees to radians.
func rad(deg float64) float64 {
 return deg * math.Pi / 180
}

func main() {
	var mars = world{radius: 3389.5}
	spirit := location{-14.5684, 175.472636}
	opportunity := location{-1.9462, 354.4734}

	dist := mars.distance(spirit, opportunity)
	fm.Printf("%.2f km\n", dist)

}
```

</details>

This approach aligns with Go's design philosophy, encouraging straightforward, composition-based code over deep inheritance hierarchies. In Go, struct composition and method delegation are often more effective and lead to simpler, more maintainable code than traditional class inheritance.

### 1.3 Composition and Forwarding

In Go, inheritance is absent, but its features can be achieved through **composition** and **forwarding**. Composition allows us to build complex structures by embedding smaller structs within larger ones. Forwarding enables us to utilize methods of embedded structs as if they were directly part of the larger struct. Go also accomplishes this through struct embedding.

#### Composition: Struct Embedding

Composition can be thought of as assembling a larger, complex structure from simpler, smaller ones. This approach not only makes the code easier to read and maintain but also aligns with Go's philosophy of simplicity and modularity. In Go, we achieve composition by embedding one struct within another. This approach is often preferred over inheritance, as it offers more flexibility.

<details><summary><b> Code</b></summary>

```go
package main

import "fmt"

// A report structure composed of separate structures for temperature and location.
type report struct {
    sol         int
    temperature temperature
    location    location
}

type temperature struct {
    high, low celsius
}

type location struct {
    lat, long float64
}

type celsius float64

func main() {
    bradbury := location{-4.5895, 137.4417}
    t := temperature{high: -1.0, low: -78.0}
    report := report{
        sol:         15,
        temperature: t,
        location:    bradbury,
    }

    fmt.Printf("%+v\n", report)
    fmt.Printf("a balmy %vº C\n", report.temperature.high)
}
```

</details>

In this example, we use a `report` struct that combines `temperature` and `location` structs. This composition-based approach keeps the structure organized and enables reusability of individual components like `temperature` and `location`.

#### Forwarding Methods

When methods are bound to "smaller" structs, the larger, composite struct can call those methods through the embedded struct. Here’s how this works:

<details><summary><b> Code</b></summary>

```go
// A method on temperature to calculate the average temperature.
func (t temperature) average() celsius {
    return (t.high + t.low) / 2
}

func main() {
    t := temperature{high: -1.0, low: -78.0}
    fmt.Printf("average %vº C\n", t.average()) // Direct call on temperature
    fmt.Printf("average %vº C\n", report.temperature.average()) // Access via embedded temperature
}
```

</details>

In the example above, the `average()` method on `temperature` can be accessed through `report.temperature.average()`, but we can also add a method to `report` itself that directly calls the `average()` method on `temperature`:

<details><summary><b> Code</b></summary>

```go
// A forwarding method that calls the average method of temperature.
func (r report) average() celsius {
    return r.temperature.average()
}

func main() {
    report := report{
        sol:         15,
        temperature: t,
        location:    bradbury,
    }
    fmt.Printf("average %vº C\n", report.average()) // Access directly on report
}
```

</details>

Using struct embedding, Go allows us to omit the field name and simply specify the struct type. The field name will default to the type name, simplifying method forwarding:

<details><summary><b> Code</b></summary>

```go
type report struct {
    sol         int
    temperature // Embedding without a field name
    location
}

func main() {
    report := report{
        sol:         15,
        temperature: t,
        location:    bradbury,
    }
    fmt.Printf("average %vº C\n", report.average()) // Direct access to temperature.average()
    fmt.Printf("%vº C\n", report.high)
    report.high = 32
    fmt.Printf("%vº C\n", report.temperature.high)
}
```

</details>

This approach eliminates the need to write explicit forwarding methods, as `report` automatically has access to `temperature`'s methods and fields.

#### Handling Naming Conflicts

If two embedded structs contain methods or fields with the same name, Go will raise a naming conflict. In such cases, you need to explicitly specify which method to use, or define a method on the composite struct to resolve the ambiguity.

For instance:

<details><summary><b> Code</b></summary>

```go
func (s sol) days(s2 sol) int {
    days := int(s2 - s)
    if days < 0 {
        days = -days
    }
    return days
}

func (l location) days(l2 location) int {
    // To-do: calculate distance
    return 5
}

func (r report) days(s2 sol) int {
    return r.sol.days(s2)
}

func main() {
    report := report{sol: 15}
    fmt.Println(report.sol.days(1446))
    fmt.Println(report.days(1446))
}
```

</details>

This allows `report` to resolve the naming conflict by creating a custom `days()` method.

#### Composition vs. Inheritance

Many influential figures in programming have advocated for composition over inheritance:

- **Gang of Four:** "Favor object composition over class inheritance."
- **Sandi Metz:** "Use of classical inheritance is always optional; every problem that it solves can be solved another way."

In Go, composition is not only a workaround for inheritance but often a more flexible and simple approach to structuring code. By relying on composition and forwarding, Go developers can design modular, maintainable, and efficient applications.

## 2. Interfaces: Structuring Behavior and Enhancing Flexibility

In Go, interfaces define a set of methods that a type must implement. Any type with methods matching an interface’s signature satisfies that interface, making it compatible without needing explicit declarations. This enables a high degree of flexibility, as types only need to have the required methods to fulfill an interface contract.

#### Defining and Using Interfaces

Go allows interfaces to be declared implicitly; once a type implements the required methods, it automatically satisfies the interface. For example:

<details><summary><b> Code</b></summary>

```go
var t interface {
    talk() string
}
```

</details>

Any type with a `talk` method returning a `string` can be assigned to `t`, which allows flexibility across different types. Here, the `martian` and `laser` types both implement the `talk` method:

<details><summary><b> Code</b></summary>

```go
type martian struct{}
func (m martian) talk() string { return "nack nack" }

type laser int
func (l laser) talk() string { return strings.Repeat("pew ", 3) }

func main() {
	fmt.Println("lesson17 Interface")
	t = martian{}
	fmt.Println(t.talk()) //nack nack

	t = laser(3)
	fmt.Println(t.talk()) //pew pew pew
}
```

</details>

By doing this, both `martian` and `laser` types can interact through the interface `t`, demonstrating polymorphism.

#### Interface Embedding in Structs

Go’s embedding feature allows for struct composition, where one struct is embedded in another, effectively inheriting its methods and properties. This design also works with interfaces. For example, by embedding `laser` into a `starship` struct, the `starship` struct can directly use `laser`’s `talk` method, allowing it to fulfill the `talker` interface.

<details><summary><b> Code</b></summary>

```go
type starship struct {
    laser
}

func main() {
	s := starship{laser(2)}

	fmt.Println(s.talk()) //pew pew
	shout(s)              //PEW PEW
}
```

</details>

This lets `starship` instances use `talk` as if it were their own method, which is particularly useful in functions accepting a `talker` interface.

#### Extending Interface Use for Flexibility

Interfaces can enhance the versatility of functions by allowing different types to be passed as parameters, as long as they implement the required methods. For example, a time conversion function that initially only worked with `time.Time` could be adapted to use an interface instead:

<details><summary><b> Code</b></summary>

```go
type etastardater interface {
    YearDay() int
    Hour() int
}

func etastardate(t etastadater) float64 {
	day := float64(t.YearDay())
	h := float64(t.Hour()) / 24.0
	return 1000 + day + h
}
```

</details>

This makes the function flexible, allowing other types like `sol` to be used as long as they implement `YearDay` and `Hour` methods.

<details><summary><b> Code</b></summary>

```go
type sol int

func (s sol) YearDay() int {
	return int(s % 668)
}
func (s sol) Hour() int {
	return 0
}

func main() {
	day := time.Date(2046, 8, 9, 6, 6, 6, 0, time.UTC)
	fmt.Printf("%.1f Curiosity has landed\n", etastardate(day))

	s := sol(1422)
	fmt.Printf("%.1f Happy birthday\n", etastardate(s))
}
```

</details>

#### Leveraging Go’s Built-in Interfaces

Go’s standard library uses numerous single-method interfaces, fostering composition over inheritance. For instance, the `fmt` package includes the `Stringer` interface, which only requires a `String()` method. By implementing `String()` for a custom type, it becomes compatible with various `fmt` package functions, making it more expressive and versatile.

<details><summary><b> Code</b></summary>

```go

type Stringer interface{
	String() string
}

type location struct {
    lat, long float64
}
func (l location) String() string {
    return fmt.Sprintf("%v %v", l.lat, l.long)
}

func main() {
	curiosity := location(-4.3413, 12.473)
	fmt.Println(curiosity)
}
```

</details>

Overall, Go’s interface system encourages modular design, where types are defined by their behavior rather than by rigid inheritance structures, making code flexible, readable, and easily testable.

## 3. Pointers

In Go, a pointer is a variable that holds the memory address of another variable, which is where the actual data is stored in RAM. Understanding how to use pointers effectively can enhance code efficiency and flexibility, especially when dealing with larger data structures or when passing data between functions. Pointers are key in scenarios where you want to reference or manipulate the actual data stored in memory rather than creating copies of it.

## 3.1 Basics and Best Practices

#### Using `&` and `*` Operators

Go uses two key operators with pointers: `&` and `*`. The `&` operator provides the address of a variable, while the `*` operator dereferences a pointer, accessing the value stored at that memory address.

<details><summary><b> Code</b></summary>

```go
answer := 42
fmt.Println(&answer) // Outputs: a memory address, e.g., 0xc0000100b0

address := &answer
fmt.Println(*address) // Outputs: 42
fmt.Printf("address is a %T\n", address) // Outputs: address is a *int
```

</details>

In contrast to C, Go does not allow pointer arithmetic (e.g., `address++`) for safety, preventing direct manipulation of memory addresses.

#### Declaring Pointer Types

In Go, pointer types can be defined explicitly by prefixing a type with `*`. This can be used in variable declarations, function parameters, return types, and struct fields. A pointer type enforces a strict type system, ensuring that a pointer to one type cannot be assigned to a pointer of another type.

<details><summary><b> Code</b></summary>

```go
china := "China"
fmt.Printf("home is a %T\n", home) //home is a *string

var home *string

home = &china
fmt.Println(*home) // Outputs: China
```

</details>

Attempting to assign a pointer of one type to a variable of a different pointer type results in a compilation error, enhancing safety in Go.

#### Basic Operations with Pointers

Pointers in Go allow you to reference the original data, avoiding unnecessary copying. You can assign different values to pointers, allowing them to point to new data, and indirectly change the values they point to using dereferencing.

<details><summary><b> Code</b></summary>

```go
// Declaring a pointer to a string
var administrator *string

scolese := "Christopher J. Scolese"
administrator = &scolese
fmt.Println(*administrator) // Outputs: Christopher J. Scolese

// Changing the reference
bolden := "Charles F. Bolden"
administrator = &bolden
fmt.Println(*administrator) // Outputs: Charles F. Bolden

// Modifying the value using dereferencing
*administrator = "Maj. Gen. Charles Frank Bolden Jr."
fmt.Println(bolden) // Outputs: Maj. Gen. Charles Frank Bolden Jr.
```

</details>

Pointers allow multiple variables to reference the same data. For example, assigning one pointer to another creates a reference, while dereferencing and assigning creates a copy. This distinction can affect memory usage and program behavior:

<details><summary><b> Code</b></summary>

```go
major := administrator
*major = "Maj. General Charles Frank Bolden Jr."
fmt.Println(bolden) // Outputs: Maj. General Charles Frank Bolden Jr.

fmt.Println(administrator == major) //true

lightfoot := "Robert M. Lightfoot Jr."
administrator = &lightfoot // Changing the reference of administrator
fmt.Println(administrator == major) // Outputs: false
```

</details>

When comparing strings, Go considers only the values for equality. But for pointers, equality requires both values and addresses to match.

<details><summary><b> Code</b></summary>

```go
charles := *major // Copies the string value
*major = "Charles Bolden"
fmt.Println(charles) // Outputs: Maj. General Charles Frank Bolden Jr.
fmt.Println(bolden)  //Charles Bolden

charles = "Charles Bolden"
fmt.Println(bolden == charles) // true, compares values
fmt.Println(&bolden == &charles) // false, compares addresses
```

</details>

#### Pointers to Structs

Go allows pointers to structs to access fields directly without needing explicit dereferencing. This is convenient and often reduces boilerplate code. When initializing structs with composite literals, you can add a `&` before the struct to create a pointer.

<details><summary><b> Code</b></summary>

```go
type person struct {
    name, superpower string
    age              int
}

timmy := &person{
    name: "Timothy",
    age:  10,
}


timmy.superpower = "flying"
fmt.Printf("%+v\n", timmy) // Outputs: &{name: Timothy superpower: flying age: 10}
```

</details>

For arrays, Go similarly performs automatic dereferencing on pointers when indexing or slicing, making pointer management straightforward when working with arrays.

<details><summary><b> Code</b></summary>

```go
superpowers := &[3]string{"flight", "invisibility", "super strength"}

fmt.Println(superpowers[0])   //invisibility
fmt.Println(superpowers[1:2]) //[invisibility super-strength]
```

</details>

#### Key Points and Safety

Go’s strict typing with pointers and its prevention of pointer arithmetic make it safer than languages like C. Pointers to strings and integers must point to values of the correct type. Additionally, Go supports the `&` operator for slice and map composite literals, but unlike arrays and structs, Go doesn’t auto-dereference them, maintaining clear and intentional use of pointers. This combination of pointer functionality, safety, and ease of use provides Go developers with the tools needed to manage memory effectively.

## 3.2 Pointers in function arguments and struct fields

#### Modifying Values Across Function Boundaries

Using pointers as function parameters in Go enables modifications that affect the original data. When passing a value to a function, Go’s default behavior is to pass a copy, so changes within the function don’t impact the original variable. However, if we pass a pointer, the function receives the address of the variable, allowing modifications to the original value through dereferencing.

<details><summary><b> Code</b></summary>

```go
type person struct {
    name       string
    superpower string
    age        int
}

// Parameter is a value, so changes won't affect the original
func birthday(p person) {
    p.age++
}

func main() {
    venus := person{name: "Venus", superpower: "imagination", age: 16}
    birthday(venus)
    fmt.Println("%+v\n", venus) // age remains 16
}
```

</details>

However, with a pointer parameter, the function can modify the original object:

<details><summary><b> Code</b></summary>

```go
// Parameter is a pointer, so changes affect the original
func birthday(p *person) {
    p.age++
}

func main() {
    venus := person{name: "Venus", superpower: "imagination", age: 16}
    birthday(&venus)
    fmt.Println("%+v\n", venus) // age is now 17
}
```

</details>

#### Pointer Receivers

Similar to parameters, struct methods in Go can use pointer receivers, allowing modifications of the receiver’s fields within the method:

<details><summary><b> Code</b></summary>

```go
func (p *person) birthday() {
    p.age++
}

func main() {
    venus := &person{name: "Venus", age: 16}
    venus.birthday()
    fmt.Println("%+v\n", venus) // age is now 17
}
```

</details>

Even without explicitly using `&` on the struct instance, Go automatically dereferences it when invoking a method with a pointer receiver. Thus, calling `venus.birthday()` works the same as `(&venus).birthday()`.

#### Internal Pointers

Go provides the ability to point to specific fields within a struct, enabling operations on nested data structures:

<details><summary><b> Code</b></summary>

```go
type stats struct {
    level            int
    endurance, health int
}

func levelUp(s *stats) {
    s.level++
    s.endurance = 42 + (14 * s.level)
    s.health = 5 * s.endurance
}

type character struct {
    name  string
    stats stats
}

func main() {
    boss := character{name: "Mary"}
    levelUp(&boss.stats)
    fmt.Printf("%+v\n", boss.stats) // Outputs updated stats for "Mary"
}
```

</details>

Here, `&boss.stats` allows you to work directly with the `stats` field of the `character` struct.

#### Modifying Arrays

Although slices are generally preferred over arrays, pointers to arrays allow direct modification of array elements:

<details><summary><b> Code</b></summary>

```go
func reset(board *[8][8]rune) {
    board[0][0] = 'r'
}

func main() {
    var board [8][8]rune
    reset(&board)
    fmt.Printf("%c", board[0][0]) // Outputs 'r'
}
```

</details>

#### Implicit Pointers in Maps and Slices

Go incorporates implicit pointers with maps and slices, so passing these types to functions allows modifications without explicit pointers.

- **Maps**: Maps are essentially implicit pointers in Go, meaning they’re not copied when passed or assigned.
- **Slices**: Slices are structs with three fields:
  1. A pointer to the array it references
  2. The slice’s length
  3. The slice’s capacity

This design lets functions and methods manipulate the underlying array through the slice’s internal pointer, without directly working with an explicit pointer.

If you need to modify the slice itself (e.g., its length or capacity), you can pass a pointer to the slice:

<details><summary><b> Code</b></summary>

```go
func reclassify(planets *[]string) {
    *planets = (*planets)[0:8]
}

func main() {
    planets := []string{"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"}
    reclassify(&planets)
    fmt.Println(planets) // Outputs the first 8 planets
}
```

</details>

#### Pointers and Interfaces

Let’s examine how pointers work with interfaces. When a struct method uses a non-pointer receiver, Go accepts either a value or a pointer for satisfying an interface:

<details><summary><b> Code</b></summary>

```go
type talker interface {
    talk() string
}

func shout(t talker) {
    louder := strings.ToUpper(t.talk())
    fmt.Println(louder)
}

type martian struct{}

func (m martian) talk() string {
    return "neck neck"
}

func main() {
    shout(martian{})  // Outputs: "NECK NECK"
    shout(&martian{}) // Outputs: "NECK NECK"
}
```

</details>

If the method has a pointer receiver, only pointers of the struct satisfy the interface:

<details><summary><b> Code</b></summary>

```go
type laser int

func (l *laser) talk() string {
    return strings.Repeat("pew ", int(*l))
}

func main() {
    pew := laser(2)
    // shout(pew)     // Error: pew does not implement talker
    shout(&pew)      // Outputs: "PEW PEW"
}
```

</details>

#### Using Pointers Wisely

While pointers are powerful, they should be used judiciously. Overusing pointers can lead to code that is harder to read and maintain.

Here's a comprehensive explanation of goroutines and concurrency in Go, rewritten in English and structured like an article:

## 4. Goroutines and Concurrency

With goroutines and channels, Go offers a simple yet powerful way to handle concurrency. By understanding their nuances, such as blocking behavior, deadlocks, and buffered vs. unbuffered channels, you can build efficient concurrent programs that are easy to understand and maintain.

### 4.1 Goroutines, Channels and Deadlocks

Goroutines and channels are powerful tools in Go for managing concurrent programming. Understanding how they work will allow you to leverage Go’s concurrent features to build efficient, scalable applications.

### 4.1.1 What is a Goroutine?

A **goroutine** is a lightweight thread managed by the Go runtime. By simply prefixing a function call with the `go` keyword, you can start a new goroutine that runs concurrently with other goroutines in your program. Goroutines are highly efficient and can handle many concurrent tasks with ease, making them a fundamental part of Go's concurrency model.

Here’s a simple example:

<details><summary><b> Code</b></summary>

```go
import (
	"fmt"
	"time"
)

func sleepyGopher() {
	time.Sleep(3 * time.Second) // Simulates work
	fmt.Println("...snore...")
}

func main() {
	go sleepyGopher() // Launches a new goroutine
	fmt.Println("this is main func")
	time.Sleep(4 * time.Second) // Allows the goroutine time to complete
}
```

</details>

<details><summary><b> Code</b></summary>
Output:

```
this is main func
...snore...
```

</details>

If the main function finishes before the `sleepyGopher` goroutine, the program ends, and the goroutine will not execute. Thus, we add a delay in the main function. A better approach is to use the `sync.WaitGroup` to ensure all goroutines complete before main exits.

#### Running Multiple Goroutines

Each `go` statement launches a separate goroutine, creating concurrent execution. Though goroutines appear to run in parallel, Go manages them via **time-slicing**, switching execution between them as needed.

Here's an example of running multiple goroutines:

<details><summary><b> Code</b></summary>

```go
func sleepyGopher(id int) {
	time.Sleep(3 * time.Second)
	fmt.Println("...snore...", id)
}

func main() {
	for i := 0; i < 5; i++ {
		go sleepyGopher(i)
	}
	time.Sleep(4 * time.Second)
}
```

</details>

Each execution may print the snore messages in different orders, as the sequence of execution among goroutines is non-deterministic.

### 4.1.2 Communicating Between Goroutines with Channels

**Channels** allow goroutines to communicate safely by passing data back and forth. You can think of a channel as a message queue for sending and receiving values.

Here’s how to create channels in Go:

<details><summary><b> Code</b></summary>

```go
// Unbuffered integer channel
unbuffered := make(chan int)

// Buffered string channel with a capacity of 10
buffered := make(chan string, 10)
```

</details>

- **Sending data:** `unbuffered <- 7`
- **Receiving data:** `i := <-unbuffered`

Channels may be **unbuffered** or **buffered**. Unbuffered channels block until data is received, while buffered channels allow values to queue up to a certain capacity.

#### Example of Goroutine Completion with an Unbuffered Channel

Here, five goroutines signal their completion by sending a unique ID to the channel `c`, which main reads sequentially.

<details><summary><b> Code</b></summary>

```go
func sleepyGopher(id int, c chan int) {
	time.Sleep(time.Duration(rand.Intn(4000)) * time.Millisecond)
	fmt.Println("...snore...", id)
	c <- id
}

func main() {
	c := make(chan int)
	for i := 0; i < 5; i++ {
		go sleepyGopher(i, c)
	}
	for i := 0; i < 5; i++ {
		gopherID := <-c
		fmt.Println("gopher", gopherID, "has finished sleeping")
	}
}
```

</details>

#### Buffered Channels

Buffered channels store multiple values, allowing goroutines to send and receive independently. This type of channel is useful when tasks don't require strict synchronization.

A buffered channel only blocks if its buffer is full during a send operation, or if it’s empty during a receive operation.

#### Using `select` with Channels

The `select` statement allows you to wait on multiple channels. When a channel operation completes, the corresponding case in `select` executes. This feature is useful when combining regular channels with timeout channels created by `time.After`.

Example:

<details><summary><b> Code</b></summary>

```go
timeout := time.After(2 * time.Second)
for i := 0; i < 5; i++ {
	select {
	case gopherID := <-c:
		fmt.Println("gopher", gopherID, "has finished sleeping")
	case <-timeout: // Timeout occurs
		fmt.Println("my patience ran out")
		return
	}
}
```

</details>

**Note:** If a `select` statement lacks cases, it will block forever.

#### Nil Channels

Uninitialized channels are `nil` and will cause permanent blocking if used for sending or receiving. Nil channels are sometimes set intentionally to prevent `select` from selecting them, enabling more control over channel operations.

### 4.1.3 Blocking and Deadlocks

When a goroutine is waiting to send or receive on a channel with no corresponding receiver or sender, it will block. If multiple goroutines end up in an unresolvable wait state, the program experiences a **deadlock**.

Example of a deadlock:

<details><summary><b> Code</b></summary>

```go
func main() {
	c := make(chan int)
	<-c // No goroutine sends to `c`, so this blocks forever
}
```

</details>

Solution: Launch a goroutine to send a value to `c`.

<details><summary><b> Code</b></summary>

```go
func main() {
	c := make(chan int)
	go func() { c <- 2 }()
	<-c
}
```

</details>

### 4.2. Example: Implementing a Pipeline with Channels

Let’s put some of these Go concurrency concepts into practice by building a simple pipeline with three goroutines. The pipeline consists of three stages: an upstream producer, a middle-stage filter, and a downstream consumer. The upstream goroutine generates a set of `string` messages and passes them to the middle-stage filter, which removes certain words. The filtered messages are then passed to the downstream goroutine for output.

#### Initial Pipeline Example

In the following example, an empty string (`""`) is used as an end-of-stream signal, marking the completion of the process. Here’s how the initial implementation looks:

<details><summary><b> Code</b></summary>

```go
// Upstream
func sourceGopher(downStream chan string) {
	for _, v := range []string{"hello world", "a bad apple", "goodbye all"} {
		downStream <- v
	}
	downStream <- ""
}

// Midstream (Filter)
func filterGopher(upStream, downStream chan string) {
	for {
		item := <-upStream
		if item == "" {
			downStream <- ""
			return
		}
		if !strings.Contains(item, "bad") {
			downStream <- item
		}
	}
}

// Downstream
func printGopher(upStream chan string) {
	for {
		v := <-upStream
		if v == "" {
			return
		}
		fmt.Println(v)
	}
}

// Execution
func main() {
	c0 := make(chan string)
	c1 := make(chan string)
	go sourceGopher(c0)
	go filterGopher(c0, c1)
	printGopher(c1)
}
```

</details>

In this example, the upstream goroutine sends an empty string (`""`) as a signal to stop. However, this approach is risky—if an empty string appears in the actual data, it could prematurely close the pipeline. A more robust solution is to use the `close` function to signal the end of a channel’s data.

<details><summary><b> Code</b></summary>

```go
close(c)
```

</details>

Using `close(c)` closes the channel, so any goroutine reading from it will receive the zero value of the channel’s type. Writing to a closed channel, however, will trigger a panic.

#### Best Practice for Closed Channels

When reading from a channel that might be closed, use the `ok` value in the read statement to check if the channel is closed:

<details><summary><b> Code</b></summary>

```go
v, ok := <-c
```

</details>

If `ok` is `false`, then channel `c` has been closed. Using this method, we can rewrite the upstream and midstream functions to handle closures more safely:

<details><summary><b> Code</b></summary>

```go
// Upstream
func sourceGopher(downStream chan string) {
	for _, v := range []string{"hello world", "a bad apple", "goodbye all"} {
		downStream <- v
	}
	close(downStream)
}

// Midstream
func filterGopher(upStream, downStream chan string) {
	for {
		item, ok := <-upStream
		if !ok {
			close(downStream)
			return
		}
		if !strings.Contains(item, "bad") {
			downStream <- item
		}
	}
}
```

</details>

#### Using `range` to Read from a Channel

In Go, reading from a channel until it’s closed is a common pattern. To simplify this process, Go provides the `range` construct, which reads values from the channel until it’s closed.

With `range`, we can further optimize the middle-stage code:

<details><summary><b> Code</b></summary>

```go
func filterGopher(upStream, downStream chan string) {
	// Using range to read from the channel
	for item := range upStream {
		if !strings.Contains(item, "bad") {
			downStream <- item
		}
	}
	close(downStream)
}
```

</details>

And similarly, the downstream code can be updated:

<details><summary><b> Code</b></summary>

```go
func printGopher(upStream chan string) {
	// Using range to read from the channel
	for v := range upStream {
		fmt.Println(v)
	}
}
```

</details>

This pipeline pattern, consisting of an upstream producer, a midstream filter, and a downstream consumer, demonstrates how to use channels and goroutines to pass data through a series of transformations. By using `close` and `range`, we can handle channel closures in a more reliable and idiomatic way, ensuring the pipeline is robust and less prone to errors.

### 4.3 Concurrent State

When multiple goroutines try to access a shared value concurrently, a race condition may occur, which is a common issue in concurrent programming. This can be avoided in Go by using a mutex (`sync.Mutex`). A mutex has two main methods: `Lock` (for locking) and `Unlock` (for unlocking). It’s often best practice to use `defer` with `Unlock` to ensure that a lock is released even if there are multiple return statements within a function.

#### Mutex

Go provides a mutex in the `sync` package, which offers exclusive locking to prevent race conditions.

<details><summary><b> Code</b></summary>

```go
import (
	"fmt"
	"sync"
)

var mu sync.Mutex

func main() {
	mu.Lock()
	defer mu.Unlock()
}
```

</details>

Using a `sync.Mutex` as a struct member is common. For instance, in a web crawler where multiple goroutines record the visit count for each webpage, a mutex prevents race conditions.

<details><summary><b> Code</b></summary>

```go
// Visited keeps track of the visited pages
type Visited struct {
	mu      sync.Mutex
	visited map[string]int
}

// VisitLink records each visit to a URL
func (v *Visited) VisitLink(url string) int {
	v.mu.Lock()
	defer v.mu.Unlock()
	count := v.visited[url]
	count++
	v.visited[url] = count
	return count
}
```

</details>

When using a mutex, be cautious of deadlocks, which occur if a mutex is locked but never unlocked due to a logic error.

#### Atomic Functions

Atomic functions offer another way to handle concurrent access by synchronizing low-level operations on integer variables and pointers. For example, `LoadInt64` and `StoreInt64` in the `atomic` package allow safe read/write operations on integers.

<details><summary><b> Code</b></summary>

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

var (
	// shutdown is a flag signaling goroutines to stop
	shutdown int64
	wg       sync.WaitGroup
)

func main() {
	wg.Add(2)

	fmt.Println("Start Goroutines")

	// Start two goroutines
	go doWork("A")
	go doWork("B")

	// Allow time for the goroutines to run
	time.Sleep(1 * time.Second)

	// Signal goroutines to shut down
	fmt.Println("Shutdown Now")
	atomic.StoreInt64(&shutdown, 1)

	wg.Wait()
}

// doWork simulates a goroutine that stops when the shutdown flag is set
func doWork(name string) {
	defer wg.Done()
	for {
		fmt.Printf("Doing %s Work\n", name)
		time.Sleep(250 * time.Millisecond)

		// Check for shutdown signal and exit if received
		if atomic.LoadInt64(&shutdown) == 1 {
			fmt.Printf("Shutting %s Down\n", name)
			break
		}
	}
}
```

</details>

The `atomic` package also includes `AddInt64`, which synchronizes integer addition by ensuring that only one goroutine performs the addition at a time, similar to atomic increment functions in other languages.

#### Long-Running Worker Goroutines

A "worker" in Go is a long-running goroutine that operates independently, often executing recurring tasks, like polling or periodic maintenance.

<details><summary><b> Code</b></summary>

```go
// Long-running worker goroutine
func worker() {
	n := 0
	next := time.After(time.Second) // Create a timer channel
	for {
		select {
		case <-next: // Wait for the timer to fire
			n++
			fmt.Println(n)
			next = time.After(time.Second) // Set up a new timer for the next loop
		}
	}
}
```

</details>

In this example, `select` and `time.After` create a timed loop. Although a simple `time.Sleep` within a loop could achieve similar behavior, using `select` here allows the worker to wait on multiple channels if expanded.

#### Comprehensive Example: Controlling a Mars Rover

Suppose a Mars rover on a planetary mission needs to execute movement commands periodically while updating its position. The rover has a worker goroutine to handle commands like changing direction, stopping, or accelerating.

Here, we use Go's `image.Point` struct to store coordinates, allowing straightforward position tracking.

<details><summary><b> Code</b></summary>

```go
func worker() {
	pos := image.Point{X: 10, Y: 10}
	direction := image.Point{X: 1, Y: 0}
	next := time.After(time.Second)
	for {
		select {
		case <-next:
			pos = pos.Add(direction)
			fmt.Println("current position is ", pos)
			next = time.After(time.Second)
		}
	}
}
```

</details>

Initially, this rover simply moves forward in a straight line. By adding a command channel, it could respond to remote commands for changing direction or stopping. This pattern could serve as a basis for more complex systems, adapting to multiple commands and allowing safe concurrent control over the rover's movements.

<details><summary><b> Code</b></summary>

```go

type command int

const (
	right = command(0)
	left  = command(1)
)

type RoverDriver struct {
	commandc chan command
}

func NewRoverDriver() *RoverDriver {
	r := &RoverDriver{
		commandc: make(chan command),
	}
	go r.drive()
	return r
}

func (r *RoverDriver) drive() {
	pos := image.Point{X: 0, Y: 0}
	direction := image.Point{X: 1, Y: 0}
	updateInterval := 250 * time.Millisecond
	nextMove := time.After(updateInterval)
	for {
		select {
		case c := <-r.commandc:
			switch c {
			case right:
				direction = image.Point{
					X: -direction.Y,
					Y: direction.X,
				}
			case left:
				direction = image.Point{
					X: direction.Y,
					Y: -direction.X,
				}
			}
			log.Printf("new direction %v", direction)

		case <-nextMove:
			pos = pos.Add(direction)
			log.Printf("move to %v", pos)
			nextMove = time.After(updateInterval)
		}
	}
}

func (r *RoverDriver) Left() {
	r.commandc <- left
}

func (r *RoverDriver) Right() {
	r.commandc <- right
}

func main() {
	r := NewRoverDriver()
	time.Sleep(3 * time.Second)
	r.Left()
	time.Sleep(2 * time.Second)
	r.Right()
	time.Sleep(1 * time.Second)
}
```

</details>

## Conclusion

Go’s design prioritizes simplicity and efficiency, favoring composition and interfaces over traditional OOP. Pointers allow direct memory manipulation, enhancing performance, especially with large data structures. Goroutines and channels provide straightforward concurrency tools, making it easy to write clear and performant code. Altogether, Go’s approach supports building scalable, maintainable, and efficient applications.

<div align="center"> 
<img src="images/01_G0.gif" width="50%" />
</div>
